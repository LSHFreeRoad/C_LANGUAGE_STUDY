4th theme : 연산자 및 반복문

비교 연산자는 값을 비교할 때 사용함 
== : 같음 , != : 다름, > : 큼, < : 작음
>= : 크거나 같음 , <= : 작거나 같음 
삼항 연산자는 if else의 축약형
( ? : ) ?앞에 값이 참이면 : 앞에 코드가 실행되고
? 앞에 값이 거짓이면 : 뒤에 코드가 실행됨 
단항 연산자 : +x , ++x 등(연산할 값이 1개)
이항 연산자 : a + b, a+=b 등(연산할 값이 2개)
삼항 연산자 : x ? a : b(연산할 값이 3개) 
변수 ? 값1 : 값2	-> 참이면 1, 거짓이면 0	
논리 연산자는 조건식이나 값을 논리적으로 판단함  
if 조건문에서 조건식을 판단할 때 주로 사용함
&& : AND(논리곱), 양쪽 모두 참일 때 참임
|| : OR(논리합), 양쪽 중 한 쪽만 참이라도 참임
! : NOT(논리 부정), 참과 거짓을 뒤집음
거짓은 0을 사용하고 참은 보통 1을 사용함 
c 언어에서는 0이 아닌 모든 값이 참임 
printf("%d\n", 1 && 1);	//둘 다 참이어야 함 
논리 연산에서 중요한 부분이 단락 평가인데 단락평가는 첫 번째 값의 결과가
확실할 때 두 번째 값은 확인(평가)하지 않는 방법이다
printf("%d\n", 1 && 0);	//첫 번째 값이 거짓이면
두 번째 값에 상관없이 전체 논리값은 거짓(0)이 됨 
불(boolean) 자료형은 논리 자료형이라고도 하며 참과
거짓을 나타냄,  C 언어는 0을 거짓으로 0이 아닌 숫자를 참으로 나타냄
stdbool.h 헤더파일을 사용하면 true(1)를 참으로 false(0)를 거짓으로 
나타낼 수가 있음, bool의 크기 :1바이트, stdbool.h에는 
자료형과 불값만 정의할 뿐 전용 서식 지정자는 없음  
비트 연산자: 비트 단위로 연산하는 연산자
비트 : 2진수를 저장하는 단위이며 컴퓨터에서 사용할 수 있는 최소 단위이며
0과 1을 나타냄 , 바이트 : 8비트 크기의 단위
&: 비트 AND(두 비트가 모두 1일 때 1)
|: 비트 OR(두 비트 중 하나라도 1이면 1)
^: 비트 XOR(배타적 OR: Exclusive OR, 두 비트가 다를 때 1)
 ~ : 비트 NOT, << : 비트를 왼쪽으로 시프트
>>: 비트를 오른쪽으로 시프트
&=: 비트 AND 연산 후 할당, |=: 비트 OR 연산 후 할당
^=: 비트 XOR 연산 후 할당, <<=: 비트를 왼쪽으로 
시프트 한 후에 할당, >>=: 비트를 오른쪽으로 쉬프트 한 후에 할당
비트 연산자는 비트로 옵션을 설정할 때 주로 사용함
-> 비트로 옵션을 설정하는 방식을 플래그라고 함 
10진수를 2진수로 쉽게 바꾸는 방법,계산기-> 프로그래머 용으로 바꿔서 하기 
unsigned char num1 = 1;	//0000 0001
unsigned char num2 = 3;	//0000 0011
printf("%d\n", num1 & num2);	//0000 0001 : 1
printf("%d\n", num1 | num2);	//0000 0011 : 3
printf("%d\n", num1 ^ num2);	//0000 0010 : 2
unsigned char num3 = 162 // 1010 0010
unsigned char num4 = ~num3;	//0101 1101 -> 93
a << b , a >> b
a를 b 횟수만큼 왼쪽 또는 오른쪽으로 이동시킴
unsigned char num5 = 3;	// 0000 0011
unsigned char num6 = 24;// 0001 1000
printf("%d\n", num5 << 3); //0001 1000 -> 3*(2의 3제곱)
printf("%d\n", num6 >> 2); //0000 0110 -> 24/(2의 제곱)
쉬프트 연산을 할 때 첫 째 자리(최상위 비트)나 
마지막 자리의 비트(최하위 비트)는 사라지게 되고 그 자리에 0이 채워진다.
부호 있는 정수와 없는 정수는 비트 연산의 결과가 다름
unsigned char num7 = 131;	//131: 1000 0011
char num8 = -125;	// -125: 1000 0011
unsigned char num8;
char num9;
num8 = num6 >> 5;
num9 = num7 >> 5; //부호 있는 자료형을 오른쪽으로 이동시키면 모자란
비트는 부호 비트로 채워짐, 부호 없는 자료형을 오른쪽으로 이동시키면 모자란
비트는 0으로 채워짐
char num12 = 113;	//113: 0111 0001
char num13 = -15;	//-15: 1111 0001	
char num14 = num12 << 2; //1100 0100 ->부호 비트가 바뀜
char num15 = num13 << 2; //1100 0100 ->부호 비트 유지
char num16 = num12 << 4; //0001 0000 ->부호 비트 유지 
char num17 = num13 << 4; //0001 0000 ->부호 비트가 바뀜
플래그(flag)는 깃발에서 유래한 용어이다.
보통 깃발을 위로 올리면 on, 아래로 내리면 off을 뜻함
이걸 정수의 비트에 활용하는 건데 비트가 1이면 on, 0이면 off를 나타낸다
8비트 크기의 자료형은 비트가 8개이므로 8가지 상태를
저장할 수 있다 0100 0001->2번째, 8번째 비트가 켜진상태
4바이트 자료형은 32비트이므로 32가지 상태를 저장할 수 있다 
특정 비트를 켤 때는 플래그 |= 마스크 , 플래그의 비트를 조작하거나
검사할 때 사용하는 숫자를 마스크라고함
unsigned char flag = 0;
flag |= 1;	//0000 0001 
마스크와 비트OR 연산자로 여덟 번째 비트를 켬
플래그의 비트를 끌 때는 플래그 &= ~마스크
unsigned char flag2 = 7; // 0000 0111
flag2 &= ~2;	//1111 1101, 마스크 값 2의 비트를 뒤집은 뒤
비트 AND 연산자로 일곱 번째 비트를 끔
끄고 싶은 비트 이외의 값은 모두 1이 됨 -> 0000 0101
플래그의 비트를 토글(켜져 있으면 끄고 꺼져 있으면 키는 것을 말함)하는 
방법은 플래그 ^= 마스크
unsigned char flag3 = 7;	//0000 0111
flag3 ^= 2;	//0000 0010 
flag3 ^= 8;	//0000 1000
printf("%u\n", flag3);	//13: 0000 1101
플래그의 비트를 토글하는 동작은 비트 XOR연산자의 특성을 활용한 것임
두 비트가 다르면 1 같으면 0이 된다
따라서 flag의 비트가 1이라면 마스크의 1과 같으므로 
0이되고 0이라면 마스크의 1과 다르므로 1이 되는 원리임
리눅스 커널의 소스코드를 보거나 하드웨어를 다룰 때 나옴
연산자 우선순위는 외울 필요는 없고 필요할 때마다
찾아보면 됨, 괄호로 연산자 우선순위를 표시해줌 
괄호를 사용한 계산식의 계산 순서 
1. 괄호를 사용한 연산자, 2. 우선순위가 높은 연산자
3. 결합 방향에 따라 순서대로 계산(+, *는 왼쪽에서 오른쪽)
괄호는 복잡한 식의 가독성을 높이기 위해 주로 사용함
할당 연산자는 우선 순위가 낮음
++,--,=,+,-,!,~ 등 변수나 숫자 앞쪽에 붙는 연산자도
연산 방향이 ← 방향이다.
단 변수 뒤에 붙는 ++, --는 연산 방향이 →이다.
num5 = 10 + 2 / (5 - 3)* ++num6;
연산 순서
1. (5-3), 2. ++num6, 3. 2 / 2, 4. 1 * 4, 5. 10 + 4
bool b1 = (false || false) && !false || false;
논리 연산자의 우선순위는 !, &&, || 순위임
연산 순서
1. (false || false), 2. !false, 3. false && true
4. false || false
int num7 = 5 == 5 < 10;
비교 연산자 중 ==보다 < 의 우선순위가 높다 
따라서 5 < 10이 먼저 계산되서 1이 나오고
1은 5와 같지 않으므로 최종결과는 0이 된다. 
int num10 = 1 << 2 + 2 << 1;
시프트 연산자와 산술 연산자 중에 산술 연산자의 우선 순위가 더 높다.
즉 <<보다 +가 먼저 계산이 된다.
따라서 2+2가 먼저 계산되어 
1 << 4 << 1의 형태가 된다. ->  1 << 4 -> 16 << 1 -> 32
연산자 우선 순위가 헷갈릴 땐 무조건 괄호를 사용할 것
if, else는 조건식이 참, 거짓일 때 두 가지만 처리할 수 있음
else if는 여러 조건을 처리할 수 있지만 매번 조건식을 지정해야됨
switch문은 조건이 많아도 손쉽게 처리할 수가 있음
switch(num1)<-- 값을 판단할 변수
{
case 1: //num1이 1일 때 실행 
	printf("1입니다.\n");
	break;
case 2: //num1이 2일 때 실행
	printf("2입니다.\n");
	break;
defalut: //아무 case에도 해당하지 않을 때 실행함
	printf("3입니다.\n");
	break;
	//defalut는 생략이 가능함
}

조건식이 바뀌지 않고 값만 바뀔 때는 switch문이 적절함
값과 조건식이 모두 바뀔 때는 else if가 적절함 
case를 중단하지 않으면 그 다음에 있는 case가 계속 실행됨
이런 상황을 fall through라고 부르며 "구멍 사이로 떨어지다"에서 
유래한 말임, default 다음에는 실행할 case가 없으므로 
break를 넣어도되고 안 넣어도 됨 
case에서 break 값을 생략하면 여러가지 값으로 같은 코드
를 실행시킬 수가 있음 
if, else if는 일일이 조건식을 나열해야 되서 처리할 숫자가 많아지면
매우 번거로워짐-> 이럴 때는 case에서 break를 생략하는 방식이 유용함
case에서 변수를 선언하려면 중괄호로 묶어줘야됨
case에서 선언한 변수는 case안에서만 사용이 가능하고 
case 밖에서나 switch문 밖에서는 사용이 안 됨
switch (2) //괄호 안에 값을 판단할 변수
{
case 1: {	//num5가 1일 때
	int num6 = 3;
	printf("1입니다.\n");
	break;
}
case 2:	//num5가 2일 때 
	printf("2입니다.\n");
	break;
default:	//아무 case에도 해당되지 않을 때 
	printf("default\n");
}
switch에 판별할 수 있는 자료형은 정수 자료형만 가능
정수 자료형인 char도 가능함, 실수나 문자열 등은 안 됨
for반복문
for(초기식 ; 조건식 ; 변화식)	//루프 선언문
{
반복할 코드 
}	//루프 본체
초기식 부터 시작해서 조건식을 판별 -> 참이면 루프를 실행 하고 변화식을
수행함 -> 다시 조건식을 판별하여 참이면 코드를 실행하고 거짓이면 반복문을
끝낸 뒤 다음 코드를 실행함 조건식 -> 루프 본체 -> 변화식 -> 조건식으로 
순환하는 부분을 루프라고 부름 
변화식은 변화식이 한 번 증가될 때 마다 한 번씩 수행함	
for 반복문은 반복 횟수가 정해져 있을 때 유용함
for 반복문 뒤에 세미콜론을 붙이면 안 됨(붙이면 떨어진 코드가 됨)
for (i = 0; i < 100; i++);
printf("Hello, world! %d\n", i);
for반복문에서 실행할 코드가 한 줄이면 중괄호 생략이
가능함, 실행할 코드가 2줄이상이면 꼭 중괄호를 써야됨
묶지 않으면 첫번째 코드만 반복문이 실행됨
for (; count > 0; count--)
{
	printf("Hello, world! %d\n", count);
} //초깃값 생략 : for반복문에 사용할 변수와 초깃값이
준비되어 있으면 초깃값 부분을 생략할 수 있음
for (i = 0,j = 0; i < 7; i++, j+=2)
	printf("i : %d, j : %d\n", i, j);
for반복문에서 변수를 2개 이상 사용하는 것이 가능함
변화식에서 여러 연산자를 사용할 수 있음 
논리 연산자를 조건식에 사용해서 i, j를 동시에 검사할 수도 있음 
for (;;)
	printf("Hello, world!\n"); //무한루프, CTRL+C로 탈출
초기식
while(조건식)
{
반복할 코드
변화식
}
초기식부터 시작해서 조건식 판별 -> 참이면 반복할 코드와
변화식 수행->조건식 다시 판별 -> 참이면 다시 반복할 코드
와 변화식 실행하고, 거짓이면 반복문을 빠져나가서 
다음 코드를 실행함, 조건식->루프 본체 및 변화식->조건식
으로 순환하는 부분이 루프(loop)이다.
while (i < 100);
{
	printf("Hello, world!\n");
	i++;
} //while뒤에 세미콜론을 붙이면 실제로는 while과
중괄호가 떨어진 상태가 되서 중괄호 안에 있는 식은 전혀 실행되지 않게 되고
i값은 계속 그대로 유지되게 된다. 따라서 무한루프 상태에 빠지게 된다. 
srand(time(NULL));	//현재 시간 값으로 시드를 결정함
int i = 0;
while (i != 3)
{
	i = rand() % 10;
	printf("%d\n", i); 
무작위로 정수를 생성하려면 srand,rand,time함수가 필요
무작위로 정수를 생성하는 행동을 난수 생성 또는 랜덤이라고 함
srand: 난수를 발생시킬 초깃값인 시드(seed)를 설정하며 보통 현재 시간
값을 사용함, rand: 난수를 발생시킴
time: 정수형태로 된 현재시간 값을 반환함
<stdlib.h>	//srand, rand 함수가 선언되있는 헤더파일
<time.h>	//time함수가 선언되있는 헤더파일
}
break는 for, while, do while, switch문에서 제어 흐름을
벗어나기 위해 사용함, continue는 제어흐름을 유지한 상태에서 코드의
실행만 건너뜀 반면에 break는 제어흐름을 중단하고 빠져나옴
for (i = 0; i < 3; i++)
{
	for (j = 0; j < 7; j++)
	{
		printf("*");
	}	//별을 일곱 개 그릴때마다 제어문자를 실행함
	printf("\n");
}
