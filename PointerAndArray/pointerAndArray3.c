#include<stdio.h>
int main()
{
	/*
	변수는 컴퓨터의 메모리 상에 생김, 변수는 이름으로 사용
	변수는 메모리의 특정 장소에 위치하고 있어서 메모리 주소
	로도 표현이 가능함, 집을 구분할 때 주소를 이용하는 것과
	마찬가지 원리임,  변수 주소 구하기 -> &변수	
	*/

	int num1 = 10;
	printf("%p\n", &num1);
	//메모리 상의 주소는 16진수이며 %p 서식지정자를 이용함,
	//%p는 pointer의 약자, 변수의 메모리 주소는 컴퓨터마다
	//실행할 때마다 달라짐 
	//메모리 주소 저장하기-> 포인터 변수에 저장함
	// 자료형 *포인터이름; -> 포인터 변수 선언
	//포인터 = &변수;	-> 포인터 변수를 줄여서 포인터라고
	//부르기도 함 
	
	int *numPtr;	//포인터 변수 선언 
	numPtr = &num1;	//num1의 주소를 numPtr에 할당
	printf("%p\n", numPtr);
	//변수가 int 형이면 변수의 메모리 주소를 저장하는 
	//포인터는 int *형이어야 함, int *는 영어로 
	//pointer to int라고 읽음, int를 가리키는 포인터라는 뜻
	//간단하게 int 포인터라고함
	//32비트 포인터의 크기는 32비트(4바이트) 16진수 8자리
	//64비트 포인터의 크기는 64비트(8바이트) 16진수 16자리 

	printf("int 포인터의 크기: %zd바이트\n", sizeof(numPtr));

	//포인터 변수에는 메모리 주소가 저장되있음, 이때 메모리
	//주소가 있는 곳으로 가서 값을 가져오고 싶다면
	//역참조 연산자(deference) *를 사용하면 됨, *포인터

	printf("%d\n", *numPtr);	//numPtr에 저장된 
	//메모리 주소로 접근해서 값을 가져옴 
	//포인터를 선언할 때 *는 이 변수가 포인터(변수)다라고 
	//알려주는 역할이고 포인터에 *을 사용할 때는 포인터의
	//메모리 주소를 역참조하겠다라는 의미이다.
	//*포인터 = 값; -> 포인터 변수에 역참조 연산자를 
	//사용한 뒤 값 저장(할당)
	//역참조 연산자는 값을 가져올 수도 있고 저장할 수도 있음

	*numPtr = 20;
	printf("%d\n", *numPtr);
	printf("%d\n", num1);	//numPtr에는 num1의 주소가 
	//저장되 있기 때문임, 역참조 연산자는 자료형을 바꾸는
	//효과를 냄, int * pointer에서 *numPtr처럼 
	//역참조를 하면 pointer to int에서 
	//pointer to를 제거한 그냥 int로 만듬
	//주소 연산자(&)도 자료형을 맞춰주는 역할을 함
	//&num1 -> address of int인데 pointer to int = 
	//address of int(자료형이 같음)
	/* 변수는 메모리 주소를 몰라도 값을 저장하거나 가져올
	수 있음, 주소 연산자는 변수의 메모리 주소를 구함
	역참조 연산자는 메모리에 저장된 값에 접근할 수 있음 
	즉 메모리 주소에 접근하여 값을 가져오고 저장함
	포인터는 변수의 메모리 주소만 가리킴
	*/
	
	printf("=================\n");
	int *num2Ptr;
	int num2 = 10;

	num2Ptr = &num2;

	*num2Ptr = 20;	//역참조로 메모리 주소에
	//접근해서 20을 할당함

	printf("%d\n", *num2Ptr);
	printf("%d\n", num2);
	
	//디버그 단축키: F5-> 디버깅 시작, 디버그 종료
	//shift F5: 디버그 종료, F10: 프로시저 단위 실행
	//디버그->창->메모리->메모리 1(디버깅 할 때)
	//메모리에서 메모리의 내용을 확인할 수 있음
	//메모리 칸에서 오른쪽으로 몇 칸 떨어진 곳에
	//조사식 1칸이 있음, 조사식 창을 이용하면 소스코드를
	//고치지 않고도 변수의 값이나 메모리 주소를 
	//확인할 수 있음

	//이처럼 디버거를 활용하면 변수의 메모리
	//주소, 포인터, 역참조를 확인하기가 편함

	long long *numPtr1;
	float *numPtr2;
	char *cPtr1;

	long long num3 = 10;
	float num4 = 3.5f;
	char c1 = 'a';

	numPtr1 = &num3;
	numPtr2 = &num4;
	cPtr1 = &c1;

	printf("%lld\n", *numPtr1);
	printf("%f\n", *numPtr2);
	printf("%c\n", *cPtr1);
	printf("%zd바이트\n", sizeof(*numPtr1));
	printf("%zd바이트\n", sizeof(*numPtr2));
	printf("%zd바이트\n", sizeof(*cPtr1));

	//포인터에 저장되는 메모리 주솟값은 정수형으로 같지만
	//선언하는 자료형에 따라 메모리에 접근하는 방법이 
	//달라짐 ,포인터를 역참조하면 선언한 자료형의 크기에
	//맞춰서 값을 가져오거나 저장하게 됨, 
	//즉 long long 포인터는 8바이트 크기만큼 값을
	//가져오거나 저장하고 char 포인터는 
	//1바이트 크기만큼 값을 가져오거나 저장함 
	
	/*
	void *포인터이름 -> 자료형이 정해지지 않은 포인터
	자료형이 정해지지 않아서 어떤 자료형으로 된 포인터
	든지 모두 저장할 수 있음, 반대로 어떤 자료형의 포인터
	에도 void 포인터를 저장할 수가 있음
	즉 직접 자료형을 변환하지 않아도 암시적으로 자료형이
	변환되는 방식이다. 단 void 포인터는 자료형이 정해지지
	않았으므로 값을 가져오거나 저장할 크기도 안 정해짐	
	*/

	int num5 = 10;
	char c2 = 'c';
	int *numPtr3 = &num5;
	char * cPtr2 = &c2;
	
	//void *ptr;

	//ptr = numPtr3;
	//printf("%d\n",*ptr);
	//void 포인터는 역참조가 안 됨
	
	//ptr = cPtr2;
	//printf("%d\n", *cPtr2);
	//void 포인터는 역참조가 안 됨

	/*
	void 포인터는 함수에서 다양한 자료형을 받아들일 때
	함수의 반환 포인터를 다양한 자료형으로 된 포인터에
	저장할 때, 자료형을 숨기고 싶을 때 등에 사용됨
	*/

	/*
	포인터의 메모리 주소를 저장하는 포인터의 포인터
	즉 이중 포인터가 됨
	자료형 ** 포인터이름	
	*/

	int *numPtr4;
	int **numPtr5;
	int num6 = 10;

	numPtr4 = &num6;
	numPtr5 = &numPtr4;

	printf("%d\n", **numPtr5);

	//포인터(변수)의 메모리 주소는 일반 포인터에 저장할
	//수 없고 이중 포인터에 저장해야 됨
	//int 이중 포인터는 영어로 pointer to pointer to int 
	//이중 포인터의 실제 값을 가져오려면 역참조 연산자를
	//두 번 사용하면 됨
	//*의 개수를 따라서 삼중, 사중 포인터 그 이상을
	//만들 수 있고 실제 값을 가져오려면 그만큼의
	//역참조를 하면 됨

	//잘못된 포인터 사용: 메모리 주소를 저장하기 위한
	//용도라서 값을 직접 저장하면 안 됨
	//int * numPtr6 = 0x100; -> 포인터에 0x100을 직접저장
	//0x100은 잘못된 메모리 주소이므로 실행에러
	//역참조가 불가능!, 하지만 실제로 존재하는 메모리
	//주소라면 저장할 수 있음

	/*
	numPtr1 = &num1;
	numPtr2 = &numPtr1;	
	*/

	return 0;

}